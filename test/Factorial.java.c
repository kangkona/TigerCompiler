// This is automatically generated by the Tiger compiler.
// Do NOT modify!

#include<memory.h>
// structures
struct Factorial
{
  struct Factorial_vtable *vptr;
  int isObjOrArray;
  int length;
  void* forwarding;
};
char Factorial_gc_map[]="";
struct Fac
{
  struct Fac_vtable *vptr;
  int isObjOrArray;
  int length;
  void* forwarding;
};
char Fac_gc_map[]="";
// vtables structures
struct Factorial_vtable
{
  char *Factorial_gc_map;
};

struct Fac_vtable
{
  char *Fac_gc_map;
  int (*ComputeFac)();
};


extern void *prev;
// methods declear
int Fac_ComputeFac(struct Fac * this, int num);
// vtables
struct Factorial_vtable Factorial_vtable_ = 
{
  Factorial_gc_map,
};

struct Fac_vtable Fac_vtable_ = 
{
  Fac_gc_map,
  Fac_ComputeFac,
};


// methods
char *Fac_ComputeFac_arguments_gc_map = "10";
int Fac_ComputeFac_locals_gc_map = 1;
struct Fac_ComputeFac_gc_frame{
void *prev;
char *arguments_gc_map;
int *arguments_base_address;
int locals_gc_map;
  struct Fac * x_1;
};
int Fac_ComputeFac(struct Fac * this, int num)
{
  struct Fac_ComputeFac_gc_frame frame;
  frame.prev = prev;
  prev = &frame;
  frame.arguments_gc_map = Fac_ComputeFac_arguments_gc_map;
  frame.arguments_base_address = (int*)&this;
  frame.locals_gc_map = Fac_ComputeFac_locals_gc_map;
  int num_aux;
  
  if (num < 1)
    num_aux = 1;

  else
    num_aux = num * ((frame.x_1=this, frame.x_1->vptr->ComputeFac(frame.x_1, num - 1)));

prev = frame.prev;
  return num_aux;
}

// main method
struct Tiger_main_gc_frame{
void *prev;
char *arguments_gc_map;
int *arguments_base_address;
int locals_gc_map;
  struct Fac * x_0;
};
char *Tiger_main_arguments_gc_map = "";
int Tiger_main_locals_gc_map = 1;
int Tiger_main ()
{
  struct Tiger_main_gc_frame frame;
  frame.prev = prev;
  prev = &frame;
  frame.arguments_gc_map = Tiger_main_arguments_gc_map;
  frame.locals_gc_map = Tiger_main_locals_gc_map;
  {

    System_out_println ((frame.x_0=((struct Fac*)(Tiger_new (&Fac_vtable_, sizeof(struct Fac)))), frame.x_0->vptr->ComputeFac(frame.x_0, 10)));
  }
  prev = frame.prev;
}



